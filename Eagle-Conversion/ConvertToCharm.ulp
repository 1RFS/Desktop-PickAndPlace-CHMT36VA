#usage "<b>Data generation for mounting machines</b>\n"
"<p>"
"Generates a .dpv work file for CharmHigh Pick and Place Machines"
"<author>Author: Nathan</author>"


#include "Include_String.ulp"


// THIS PROGRAM IS PROVIDED AS IS AND WITHOUT WARRANTY OF ANY KIND, EXPRESSED OR IMPLIED

//Sometimes you just need to jog everything
real offsetY = 0.0; //0.5 = move everything up 0.5mm
real offsetX = 0.0; //0.5 = move everything to right 0.5mm

string pnpName[];
string pnpDesignator[];
int    pnpX[];
int    pnpY[];
real   pnpAngle[];
int    pnpFeeder[];
int    pnpPos[];    //Top or bottom
int    pnpCount;    
int    pnpStatsPartsTotal;
int    pnpStatsPartsOk;
int    pnpStatsPartsNew;
int    pnpStatsPartsDnp;



string usedFeederList[]; //Keeps track of the components in the feeders
string availableFeederList[];
string availableFeederHeadline;
int numberOfFeeders;

string hasFiducials = "False"; //Goes true when board has fiducials located

int feederID = 0; //The tape this part assigned to
real feederXOffset = 0.0; //In mm. Offset from the default pick point
real feederYOffset = 0.0;
int feederFeedDistance = 4; //mm between components on tape. 2, 4, 8, 12, 16, or 24mm. Most 8mm wide tapes are 4mm between components.
real feederPickHeight = 0.5; //In mm. 0.5 is default.
int feederPickSpeed = 0; //1 to 100%. 0 will follow master control.
real componentSizeX = 0.1; //Size of component in mm
real componentSizeY = 0.1;
int feederHead = 1; //There are two heads: 1 or 2
int componentRotation = 0; //If the eagle FP is created different from how the IC is packaged in the tape, this offset unites the two.
string mountComponent = "True"; //Most components will be mounted

string newPart = "False"; //Goes true when a component is not found in setPartProfile()
string listOfNewParts = ""; //String of all the new parts not found in partProfile list

string listOfKnownParts = ""; //String of all the feeders used

int NO_MOUNT = 30;
string NO_MOUNT_STR = "No Mount";
int NEW_SKIP = 31;

//TODO Add flags for check vacuum and check vision of a given feeder

//Adds the opening header information to the dpv file
void addHeader()
{
  //File header
  printf("separated\n");
  printf("FILE,SparkFun_Conversion_Script.dpv\n");
  printf("PCBFILE,SparkFun_Conversion_Script\n");
  printf("DATE,2017/11/27\n"); //Todo pull in current date/time
  printf("TIME,14:42:01\n");
  printf("PANELYPE,0\n"); //Typo is correct. Type 0 = batch of PCBs. Type 1 = panel of PCBs. See addBatch() for info.
  printf("\n");
}

//Add this feeder name and ID to the used feeder list
void addFeederToList(string partName, int feederID)
{
  //See if this is already in the list
  int pos = strstr(listOfKnownParts, partName);

  if (pos == -1)
  {
    string newFeederID = "";
    sprintf(newFeederID, "%d", feederID);
    listOfKnownParts = listOfKnownParts + newFeederID + ") " + partName + '\n';
  }
}

//Given a component ID, try to find its name in the available feeders
//Search the feeder list of aliases as well
//Returns the ID of the feeder
int locateFeederNumber(string partName)
{
  //Search the list of feeders for this part name
  int feederNumber;
  for (feederNumber = 0 ; feederNumber < numberOfFeeders ; feederNumber++)
  {
    string thisLine = availableFeederList[feederNumber];

    string feederData[];
    strsplit(feederData, thisLine, ',');

	  //dlgMessageBox(feederData[2] + " "+ partName);
	
    if (feederData[2] == partName)
    {
      return (feederNumber);
    }

    //Check aliases
    //Take what's in column 15 and split it up, then search it
    string aliases[];
    int count = strsplit(aliases, feederData[15], ':');

    for (int y = 0 ; y < count ; y++)
    {
	  if(aliases[y] != "") //The strsplit above returns some weird records with zero length, ignore them
	  {
		  //See if this alias is anywhere within the partName
		  int pos = strstr(partName, aliases[y]);
		  if (pos != -1) //This alias has been found in the partName
		  {

			if (feederData[2] == NO_MOUNT_STR)
			{
				//This is an alias for a non-mount device
				return (NO_MOUNT);
			}
			else
			{
				return (feederNumber); //Return this feeder number
			}
		  }
		 }
    }

    if (feederData[2] == "Stop")
    {
      //We hit the end of the list, we didn't find it.
      return NO_MOUNT;  //We don't want to mount parts that we don't have in feeders
      //return (NEW_SKIP);
    }
  }

  //dlgMessageBox("Error in feeder lookup: You shouldn't be here", "OK");
  return (NEW_SKIP); //We should not get here
}

//Given a part name set the various feeder aspects
string setPartProfile(string partName)
{
  //Find the line in the feeder file that contains this partName
  int lineNumber = locateFeederNumber(partName);

  //Set the part specs
  if (lineNumber == NO_MOUNT)
  {
    //Do nothing with this part
    return (NO_MOUNT_STR);
  }
  else if (lineNumber == NEW_SKIP)
  {
    //New, unidentified component. Use defaults.
    newPart = "True";

    //See if this is already in the list
    int pos = strstr(listOfNewParts, partName);

    if (pos == -1)
    {
      listOfNewParts = listOfNewParts + partName + '\n';
    }

    //Set this to defaults
    feederID = 0; //No feeder assigned
    feederXOffset = 0.0; //No offset
    feederYOffset = 0.0;
    feederPickHeight = 0.5; //In mm. 0.5 is default.
    feederPickSpeed = 0; //1 to 100%. 0 will follow master control.
    feederHead = 1;
    componentRotation = 0;
    feederFeedDistance = 4; //2, 4, 8, 12, 16, or 24mm. 4mm is most common.
    mountComponent = "False";

    componentSizeX = 0.0; //Size of component in mm
    componentSizeY = 0.0;
	
    return (partName);
  }
  else
  {
    //Get the data for this feeder
    string feeder[];
    string thisLine = availableFeederList[lineNumber];
    strsplit(feeder, thisLine, ',');

    feederID = strtod(feeder[1]);
    partName = (feeder[2]);
    feederXOffset = strtod(feeder[3]);
    feederYOffset = strtod(feeder[4]);
    feederPickHeight = strtod(feeder[5]); //In mm. 0.5 is default.
    feederPickSpeed = strtod(feeder[6]); //1 to 100%. 0 will follow master control.
    feederHead = strtod(feeder[7]);
    componentRotation = strtod(feeder[8]);
    feederFeedDistance = strtod(feeder[9]); //2, 4, 8, 12, 16, or 24mm

    mountComponent = "True";
    if (feeder[10] != "Y")
    {
      mountComponent = "False";
    }
    //11 = Check Vacuum
    //12 = Use Vision
    //13 = Centroid Correction X
    //14 = Centroid Correction Y
    //15 = Aliases

    componentSizeX = 0.0; //Size of component in mm
    componentSizeY = 0.0;

    addFeederToList(partName, feederID);
    return (partName);
  }
}

//Figures out the feeders needed and creates a material stack
void addFeeders()
{
  board(X)
  {
    //Create Material Stack
    printf("\n");
    printf("Table,No.,ID,DeltX,DeltY,FeedRates,Note,Height,Speed,Status,SizeX,SizeY\n");

    int stackNumber = 0;

    X.elements(E) if (E.populate) {

      string componentName = E.value + '-' + E.package.name;

      int isSmd = 0;

      E.package.contacts(C) {
        if (C.smd && C.smd.layer == 1) {
          isSmd = 1;
        }
      }

      if (isSmd)
      {
		//For every SMD component on this design, look up its feeder
        componentName = setPartProfile(componentName); //This will, if possible, resolve any aliases to a known part name

        //Filter out stuff that is not actually SMD mounted devices
        if (componentName == NO_MOUNT_STR)
        {
          //This component does not need a feeder record
        }
        else
        {
          //Do we already have this entry in the feeder list?
          string componentNameLookup = lookup(usedFeederList, componentName, 0);

          //If the component is not found then add it to the used feeder list
          if (componentNameLookup == "")
          {
            //Table,No.,ID,DeltX,DeltY,
            //FeedRates,Note,Height,Speed,
            //Status,SizeX,SizeY

            //0b.0000.0ABC
            //A = 1 = Use Vision
            //A = 0 = No Vision
            //B = 1 = Use Vacuum Detection
            //B = 0 = No Vacuum Detection
            //C = 1 = Skip placement
            //C = 0 = Place this component
            //Example: 3 = no place, vac, no vis

            int mountValue = 6;
            if (mountComponent == "False") mountValue = 7;

            //Station,0,1,0,0,4, 0.1uF,0.5,0,6,0,0
            printf("Station, %d, %d, %.2f, %.2f, %d, %s, %.2f, %d, %d, %.2f, %.2f\n",
                   stackNumber, feederID, feederXOffset, feederYOffset,
                   feederFeedDistance, componentName, feederPickHeight, feederPickSpeed,
                   mountValue, componentSizeX, componentSizeY); //mountValue: 6 is to place, 7 is to skip

            //Add this package to the lookup table so we don't use it again
            usedFeederList[stackNumber] = componentName;

            stackNumber++;
          }
        }
      }
    }
  }
}


void addBatch()
{
  //Batch is where the user takes multiple copies of the same design and mounts them
  //into the machine at the same time.
  //Doing an array is where you have one PCB but X number of copies panelized into an array

  //If you are doing a batch then the header is
  //PANELYPE,0
  //If you are doing an array then the header is
  //PANELYPE,1
  //Typo is correct.

  printf("\n");

  //When there is a batch of boards it looks like this
  printf("Table,No.,ID,DeltX,DeltY\n");
  printf("Panel_Coord,0,1,0,0\n");

  //When you define an array you get this:
  //Table,No.,ID,IntervalX,IntervalY,NumX,NumY
  // IntervalX = x spacing. Not sure if this is distance between array
  // NumX = number of copies in X direction
  //Panel_Array,0,1,0,0,2,2

  //If you have an X'd out PCB in the array you can add a skip record.
  //When you add a skip, you get another
  //Panel_Array,1,4,0,0,2,2 //Skip board #4 in the array
  //This doesn't quite make sense but skips will most likely NOT be automated (user will input an X'd out board during job run)

}

void addComponents()
{
  //TODO - When you press USE DUAL NOZZLE the program figures out some sort of
  //best use of two heads. Perhaps we just let the user click this button rather than
  //try to automate it.

  printf("\n");
  printf("Table,No.,ID,PHead,STNo.,DeltX,DeltY,Angle,Height,Skip,Speed,Explain,Note\n");

  int componentNumber = 0;
  int componentID = 1;

  board(X)
  {
    X.elements(E) if (E.populate) {

      string componentName = E.value + '-' + E.package.name;

      int isSmd = 0,
          xmax = -2147483648,
          xmin = 2147483647,
          ymax = xmax,
          ymin = xmin;

      E.package.contacts(C) {
        if (C.smd && C.smd.layer == 1) {
          isSmd = 1;

          if (C.x > xmax) xmax = C.x;
          if (C.y > ymax) ymax = C.y;
          if (C.x < xmin) xmin = C.x;
          if (C.y < ymin) ymin = C.y;
        }
      }

      if (isSmd)
      {
		//For every SMD component on this design, look up its component info
        componentName = setPartProfile(componentName); //This will, if possible, resolve any aliases to a known part name

		
        //Filter out stuff that is not actually SMD mounted devices
        if (componentName == NO_MOUNT_STR)
        {
          //These devices are not mounted so ignore them
        }
        else
        {
          //Most all Eagle FPs are correct but we have to subtract 90 because
          //the tapes are mounted 90 degrees from the board
          real convertedAngle = E.angle - 90;

          //However, some feeders/FPs were designed not horizontal so we correct on a component by component basis
          convertedAngle = convertedAngle + componentRotation;
          if (convertedAngle > 180) convertedAngle -= 360;

          //The material stack contains all the feeder information. We must assign the proper feederID
          //to this component so the machine knows where and how to pick it.

          //Example output
          //Table,No.,ID,PHead,STNo.,DeltX,DeltY,Angle,Height,Skip,Speed,Explain,Note
          //EComponent,0,1,1,1,16.51,12.68,0,0.5,6,0,C4, 0.1uF

          int mountValue = 6;
          if (mountComponent == "False") mountValue = 7;

          printf("EComponent, %d, %d, %d, %d, %.2f, %.2f, %.2f, %.2f, %d, %d, %s, %s\n",
                 componentNumber, componentID, feederHead, feederID,
                 u2mm((xmin + xmax) / 2) + offsetX, u2mm((ymin + ymax) / 2) + offsetY, convertedAngle, feederPickHeight,
                 mountValue, 0, E.name, componentName); //mountValue: 6 is to place, 7 is to skip

          componentNumber++;
          componentID++;
        }
      }
    }

  }

}

//Add any IC tray info
void addICTray()
{
  printf("\n");
  printf("Table,No.,ID,CenterX,CenterY,IntervalX,IntervalY,NumX,NumY,Start\n");
}

void addPCBCalibrate()
{
  //Flags to say what type and if calibration of the board has been done
  printf("\n");
  printf("Table,No.,nType,nAlg,nFinished\n");
  printf("PcbCalib,0,0,0,0\n");

  //nType: 0 = use components as calibration marks, 1 = use marks as calibration marks
  //nFinished: ? 0 = you haven't cal'd a board, 1 = you have cal'd the board
}

void addFiducials()
{
  //Adds the fiducials or mark information about this board or panel
  //TODO - Should we pull in the marks from the PCB file? It might make better
  //sense to have user do this manually as it will be pretty specific.
  printf("\n");
  printf("Table,No.,ID,offsetX,offsetY,Note\n");
  printf("CalibPoint,0,1,3.14,12.66,Mark1\n");
  printf("CalibPoint,1,2,22.16,12.66,Mark2\n");
}

void addCalibrationFactor()
{
  //Add the calibration factor. This is all the offsets calculated when the
  //PCB is calibrated. We don't have to set anything here because the program
  //will calculate things after user calibrates the PCB.

  printf("\n");
  printf("Table,No.,DeltX,DeltY,AlphaX,AlphaY,BetaX,BetaY,DeltaAngle\n");
  printf("CalibFator,0,0,0,0,0,1,1,0\n"); //Typo is required
}

void downloadFeederData(){
    string spreadsheet_key = "1Ji8-ulmfizbTw11OVJ1ojtQojZbGBaaUEyQ4R7oua1U";
    numberOfFeeders = netget(availableFeederList, "https://docs.google.com/spreadsheet/ccc?key=" + spreadsheet_key + "&output=csv");
    if (numberOfFeeders == 0)
    {
      dlgMessageBox("Error: Feeder file not found. Run UpdateFeederData.py to create the feeder file.", "OK");
      exit(0);
    }

    availableFeederHeadline = stringReplace(availableFeederList[0], ",", "\t");

    //Process feeder data to be TSV instead of CSV
    for(int i = 1; i < numberOfFeeders; i++){
      availableFeederList[i-1] = stringReplace(availableFeederList[i], ",", " \t");
    }
    availableFeederList[numberOfFeeders-1] = "";
    numberOfFeeders--;

}
//Indicies to the online table
int ROW_FEEDERID  = 1;
int ROW_COMPNAME  = 2;
int ROW_XOFFSET   = 3;
int ROW_YOFFSET   = 4;
int ROW_HEIGHT    = 5;
int ROW_SPEED     = 6;
int ROW_HEAD      = 7;
int ROW_RELTAPE   = 8;
int ROW_SPACING   = 9;
int ROW_PLACE     = 10;
int ROW_CHECK_VAC = 11;
int ROW_USE_VISION= 12; 
int ROW_ALIAS     = 15; 

int MAX_FEEDER    = 29;

string getFeederParameterByLine(int line, int row){
  string feederData[];
  strsplit(feederData, availableFeederList[line], '\t'); 
  return feederData[row];
}

string getFeederParameter(int feeder, int row){
  //Check if the table is aligned correctly (line 1 is feeder 1)
  if(strtod(getFeederParameterByLine(feeder-1, ROW_FEEDERID)) == feeder){
    return getFeederParameterByLine(feeder-1, row);
  }

  //If not aligned, we need to work harder
  for(int i = 0; i < numberOfFeeders; i++){
    if(strtod(getFeederParameterByLine(i, ROW_FEEDERID)) == feeder){
      return getFeederParameterByLine(i, row);
    }
  }    
  return "";
}

int getFeederId(string name) {
  for(int i = 1; i <= MAX_FEEDER; i++){
    string fname   = getFeederParameter(i, ROW_COMPNAME);
    string falias  = getFeederParameter(i, ROW_ALIAS); 

    //Check component name
    if(fname == name){
      return i;
    }

    //Check aliases 
    string aliases[];
    int cnt = strsplit(aliases, falias, ':');     
    for(int k = 0; k < cnt; k++){
      if(stringTrim(aliases[k]) == name){
        return i;
      }
    }
  }
  return -1;
}

void loadBoardInformation() {
  pnpCount            = 0;
  pnpStatsPartsTotal  = 0;
  pnpStatsPartsOk     = 0;
  pnpStatsPartsNew    = 0;
  pnpStatsPartsDnp    = 0;

  board(X) {
    X.elements(E) {

      int isSmd = 0;
      int isBottom = 0;

      E.package.contacts(C) {
        if (C.smd && C.smd.layer == 1) {
          isSmd = 1;
        }
        if (C.smd && C.smd.layer == 16) {
          isSmd = 1;
          isBottom = 1;
        }
      }

      if (isSmd) {
        pnpName[pnpCount]       = E.value + '-' + E.package.name;
        pnpDesignator[pnpCount] = E.name;
        pnpX[pnpCount]          = E.x;
        pnpY[pnpCount]          = E.y;
        pnpAngle[pnpCount]      = E.angle;
        pnpPos[pnpCount]        = isBottom;

        if(E.populate && E.attribute["POPULATE"] != "DNP"){
          pnpFeeder[pnpCount]     = getFeederId(pnpName[pnpCount]);
        } else {
          pnpFeeder[pnpCount]   = -2;
        }

        pnpStatsPartsTotal++;
        if(pnpFeeder[pnpCount] == -1){
          pnpStatsPartsNew++;
        } else if(pnpFeeder[pnpCount] == -2){
          pnpStatsPartsDnp++;
        } else {
          pnpStatsPartsOk++;
        }


        pnpCount++;
      }
    } 
  }



}


void writeOutputFile() {
  /*
    output(fileName) {
      addHeader(); //Static header
      addFeeders(); //Calculate the needed feeders
      addBatch(); //Array of PCBs?
      addComponents(); //You know, the things we're trying to place?
      addICTray(); //Add any IC tray info here.
      addPCBCalibrate(); //Add flag?
      addFiducials(); //Add the fiducial/mark information
      addCalibrationFactor(); //Add the calibration factor
    }  
    */
}


int showListOfDevices()
{
  int selected = 0;
  int sorted = 0;
  int quantity = 1;


  downloadFeederData();

  //bomLoadData();
  while(1)
  {
    loadBoardInformation();

    string partlist[];
    for(int i = 0; i < pnpCount; i++){
      partlist[i] = "";
      string feeder = "";
      if(pnpFeeder[i] == -1){
        feeder = "No feeder assigned!";
      } else if(pnpFeeder[i] == -2){
        feeder = "Do not mount!";
      } else {
        sprintf(feeder, "%d", pnpFeeder[i]);
      }

      sprintf(partlist[i], "%s\t%s\t%s\t%.2fmm\t%.2fmm\t%.1f°\t%s", pnpDesignator[i], pnpName[i], (pnpPos[i]==0)?"Top":"Bottom", u2mm(pnpX[i]), u2mm(pnpY[i]), pnpAngle[i], feeder);
    }
  
    int dstatus = dlgDialog("Feeder configuration"){
      dlgHBoxLayout{
        dlgVBoxLayout dlgSpacing(800);
        dlgTabWidget {
          dlgTabPage("Parts overview") {
            dlgListView("Designator\tComponent\tPosition\tPos X\tPos Y\tAngle\tFeeder", partlist, selected, sorted){
              dlgAccept();
            }
          }
          dlgTabPage("Feeder config") {
            dlgListView(availableFeederHeadline, availableFeederList, selected, sorted){
              dlgAccept();
            }
          }
        }
        dlgVBoxLayout {
          dlgGroup("Statistics") { 
               dlgHBoxLayout{ dlgLabel("Parts total:\t");   dlgLabel(itoa(pnpStatsPartsTotal)); }
               dlgHBoxLayout{ dlgLabel("Parts ok:\t\t");   dlgLabel(itoa(pnpStatsPartsOk)); }
               dlgHBoxLayout{ dlgLabel("Parts not assigned:\t");   dlgLabel(itoa(pnpStatsPartsNew)); }
               dlgHBoxLayout{ dlgLabel("Parts not mounted:\t");   dlgLabel(itoa(pnpStatsPartsDnp)); }
          }
          dlgGroup("Operations") {
             dlgPushButton("Refresh Feeder List") {
              downloadFeederData();
              dlgAccept();
            }           
          }
          dlgStretch(1);
        }
      }
    };

    if(dstatus == -1){break;}
  }

  return 1;
}

if (!board) {
    dlgMessageBox("\n    Start this ULP in a Board    \n");
    exit (0);  
} else {
    showListOfDevices();
}
