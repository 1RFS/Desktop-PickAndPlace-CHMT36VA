#usage "<b>Data generation for mounting machines</b>\n"
"<p>"
"Generates a .dpv work file for CharmHigh Pick and Place Machines"
"<author>Author: Nathan</author>"


#include "Include_String.ulp"


// THIS PROGRAM IS PROVIDED AS IS AND WITHOUT WARRANTY OF ANY KIND, EXPRESSED OR IMPLIED

//Sometimes you just need to jog everything
real offsetY = 0.0; //0.5 = move everything up 0.5mm
real offsetX = 0.0; //0.5 = move everything to right 0.5mm

string pnpName[];
string pnpDesignator[];
int    pnpX[];
int    pnpY[];
real   pnpAngle[];
int    pnpFeeder[];
int    pnpPos[];    //Top or bottom
int    pnpCount;    
int    pnpStatsPartsTotal;
int    pnpStatsPartsOk;
int    pnpStatsPartsNew;
int    pnpStatsPartsDnp;
string pnpBasefile;

string  usedFeederList[]; //Keeps track of the components in the feeders
string  availableFeederList[];
string  availableFeederHeadline;
int     numberOfFeeders;

int maxX = 0;
int minX = 0;
int maxY = 0;
int minY = 0;
int initialized = 0;


//TODO Add flags for check vacuum and check vision of a given feeder

//Indicies to the online table
int ROW_FEEDERID  = 1;
int ROW_COMPNAME  = 2;
int ROW_ALIAS     = 3; 
int ROW_XOFFSET   = 4;
int ROW_YOFFSET   = 5;
int ROW_HEIGHT    = 6;
int ROW_LENGTH    = 7;
int ROW_WIDTH     = 8;
int ROW_SPEED     = 9;
int ROW_HEAD      = 10;
int ROW_RELTAPE   = 11;
int ROW_SPACING   = 12;
int ROW_PLACE     = 13;
int ROW_CHECK_VAC = 14;
int ROW_USE_VISION= 15; 

int MAX_FEEDER    = 29;

int FEEDER_NEW    = -1;
int FEEDER_DNP    = 0;

string getFeederParameterByLine(int line, int row){
  string feederData[];
  strsplit(feederData, availableFeederList[line], '\t'); 
  return feederData[row];
}

string getFeederParameter(int feeder, int row){
  //Check if the table is aligned correctly (line 1 is feeder 1)
  if(feeder > 0) {
    if(strtod(getFeederParameterByLine(feeder-1, ROW_FEEDERID)) == feeder){
      return getFeederParameterByLine(feeder-1, row);
    }
  }

  //If not aligned, we need to work harder
  for(int i = 0; i < numberOfFeeders; i++){
    if(strtod(getFeederParameterByLine(i, ROW_FEEDERID)) == feeder){
      return getFeederParameterByLine(i, row);
    }
  }    
  return "";
}

int getFeederId(string name) {
  for(int i = 0; i <= MAX_FEEDER; i++){
    string fname   = getFeederParameter(i, ROW_COMPNAME);
    string falias  = getFeederParameter(i, ROW_ALIAS); 

    //Check component name
    if(fname == name){
      return i;
    }

    //Check aliases 
    string aliases[];
    int cnt = strsplit(aliases, falias, ':');     
    for(int k = 0; k < cnt; k++){
      if(stringTrim(aliases[k]) == name){
        return i;
      }
    }
  }
  return -1;
}

//Adds the opening header information to the dpv file
void addHeader()
{
  //File header
  printf("separated\n");
  printf("FILE,SparkFun_Conversion_Script.dpv\n");
  printf("PCBFILE,SparkFun_Conversion_Script\n");
  printf("DATE,2017/11/27\n"); //Todo pull in current date/time
  printf("TIME,14:42:01\n");
  printf("PANELYPE,0\n"); //Typo is correct. Type 0 = batch of PCBs. Type 1 = panel of PCBs. See addBatch() for info.
  printf("\n");
}


//Figures out the feeders needed and creates a material stack
void addFeeders(int position)
{
  //Create Material Stack
  printf("\n");
  printf("Table,No.,ID,DeltX,DeltY,FeedRates,Note,Height,Speed,Status,SizeX,SizeY\n");

  int stackNumber = 0;

  for(int i = 1; i <= MAX_FEEDER; i++){
    //Check if feeder is used
    int used = 0;
    for(int k = 0; k < pnpCount; k++){
      if(pnpPos[k] == position && pnpFeeder[k] == i){
        used = 1;
        break;
      }
    }

    if(used){
      //Table,No.,ID,DeltX,DeltY,
      //FeedRates,Note,Height,Speed,
      //Status,SizeX,SizeY

      //0b.0000.0ABC
      //A = 1 = Use Vision
      //A = 0 = No Vision
      //B = 1 = Use Vacuum Detection
      //B = 0 = No Vacuum Detection
      //C = 1 = Skip placement
      //C = 0 = Place this component
      //Example: 3 = no place, vac, no vis

      //Station,0,1,0,0,4, 0.1uF,0.5,0,6,0,0
      printf("Station, %d, %d, %s, %s, %s, %s, %s, %s, %d, %2.0f, %2.0f\n",
             stackNumber, i, 
             getFeederParameter(i, ROW_XOFFSET), getFeederParameter(i, ROW_YOFFSET),
             getFeederParameter(i, ROW_SPACING), getFeederParameter(i, ROW_COMPNAME), 
             getFeederParameter(i, ROW_HEIGHT), getFeederParameter(i, ROW_SPEED),6, 
             strtod(getFeederParameter(i, ROW_LENGTH))*100, 
             strtod(getFeederParameter(i, ROW_WIDTH))*100
      ); 
      //mountValue: 6 is to place, 7 is to skip

      stackNumber++;
    }
  }
}


void addBatch()
{
  //Batch is where the user takes multiple copies of the same design and mounts them
  //into the machine at the same time.
  //Doing an array is where you have one PCB but X number of copies panelized into an array

  //If you are doing a batch then the header is
  //PANELYPE,0
  //If you are doing an array then the header is
  //PANELYPE,1
  //Typo is correct.

  printf("\n");

  //When there is a batch of boards it looks like this
  printf("Table,No.,ID,DeltX,DeltY\n");
  printf("Panel_Coord,0,1,0,0\n");

  //When you define an array you get this:
  //Table,No.,ID,IntervalX,IntervalY,NumX,NumY
  // IntervalX = x spacing. Not sure if this is distance between array
  // NumX = number of copies in X direction
  //Panel_Array,0,1,0,0,2,2

  //If you have an X'd out PCB in the array you can add a skip record.
  //When you add a skip, you get another
  //Panel_Array,1,4,0,0,2,2 //Skip board #4 in the array
  //This doesn't quite make sense but skips will most likely NOT be automated (user will input an X'd out board during job run)

}

int transformCoordinateX(int x, int pos){
  if(pos == 0){
    return x - minX;
  } else {
    return maxX - x;
  }
}

int transformCoordinateY(int y, int pos){
  if(pos == 0){
    return y - minY;
  } else {
    return maxY - y;
  }
}


void addComponents(int position)
{
  printf("\n");
  printf("Table,No.,ID,PHead,STNo.,DeltX,DeltY,Angle,Height,Skip,Speed,Explain,Note\n");

  int componentNumber = 0;
  int componentID = 1;

  for(int i = 0; i < pnpCount; i++){
    if(pnpPos[i] == position && pnpFeeder[i] > 0){
      //Most all Eagle FPs are correct but we have to subtract 90 because
      //the tapes are mounted 90 degrees from the board
      real convertedAngle = pnpAngle[i] - 90;
      //However, some feeders/FPs were designed not horizontal so we correct on a component by component basis
      if (convertedAngle > 180) convertedAngle -= 360;

      printf("EComponent, %d, %d, %s, %d, %.2f, %.2f, %.2f, %.2f, %d, %s, %s, %s\n",
             componentNumber, componentID, getFeederParameter(pnpFeeder[i], ROW_HEAD), pnpFeeder[i],
             u2mm(transformCoordinateX(pnpX[i], pnpPos[i])) + offsetX, 
             u2mm(transformCoordinateY(pnpY[i], pnpPos[i])) + offsetY, 
             convertedAngle, strtod(getFeederParameter(pnpFeeder[i], ROW_HEIGHT)),
             6, getFeederParameter(pnpFeeder[i], ROW_SPEED), 
             pnpDesignator[i], pnpName[i]); //mountValue: 6 is to place, 7 is to skip

      //Example output
      //Table,No.,ID,PHead,STNo.,DeltX,DeltY,Angle,Height,Skip,Speed,Explain,Note
      //EComponent,0,1,1,1,16.51,12.68,0,0.5,6,0,C4, 0.1uF

      componentNumber++;
      componentID++;
    }
  }
}

//Add any IC tray info
void addICTray()
{
  printf("\n");
  printf("Table,No.,ID,CenterX,CenterY,IntervalX,IntervalY,NumX,NumY,Start\n");
}

void addPCBCalibrate()
{
  //Flags to say what type and if calibration of the board has been done
  printf("\n");
  printf("Table,No.,nType,nAlg,nFinished\n");
  printf("PcbCalib,0,0,0,0\n");

  //nType: 0 = use components as calibration marks, 1 = use marks as calibration marks
  //nFinished: ? 0 = you haven't cal'd a board, 1 = you have cal'd the board
}

void addFiducials()
{
  //Adds the fiducials or mark information about this board or panel
  //TODO - Should we pull in the marks from the PCB file? It might make better
  //sense to have user do this manually as it will be pretty specific.
  printf("\n");
  printf("Table,No.,ID,offsetX,offsetY,Note\n");
  printf("CalibPoint,0,1,3.14,12.66,Mark1\n");
  printf("CalibPoint,1,2,22.16,12.66,Mark2\n");
}

void addCalibrationFactor()
{
  //Add the calibration factor. This is all the offsets calculated when the
  //PCB is calibrated. We don't have to set anything here because the program
  //will calculate things after user calibrates the PCB.

  printf("\n");
  printf("Table,No.,DeltX,DeltY,AlphaX,AlphaY,BetaX,BetaY,DeltaAngle\n");
  printf("CalibFator,0,0,0,0,0,1,1,0\n"); //Typo is required
}

void writeOutputFile(int layer, string prefix) {
  output(filesetext(pnpBasefile, prefix + ".dpv")) {
    addHeader();            //Static header
    addFeeders(layer);      //Calculate the needed feeders
    addBatch();             //Array of PCBs?
    addComponents(layer);   //You know, the things we're trying to place?
    addICTray();            //Add any IC tray info here.
    addPCBCalibrate();      //Add flag?
    addFiducials();         //Add the fiducial/mark information
    addCalibrationFactor(); //Add the calibration factor
  }  
}


void downloadFeederData(){
    string spreadsheet_key = "1Ji8-ulmfizbTw11OVJ1ojtQojZbGBaaUEyQ4R7oua1U";
    numberOfFeeders = netget(availableFeederList, "https://docs.google.com/spreadsheet/ccc?key=" + spreadsheet_key + "&output=csv");
    if (numberOfFeeders == 0)
    {
      dlgMessageBox("Error: Feeder file not found. Run UpdateFeederData.py to create the feeder file.", "OK");
      exit(0);
    }

    availableFeederHeadline = stringReplace(availableFeederList[0], ",", "\t");

    //Process feeder data to be TSV instead of CSV
    for(int i = 1; i < numberOfFeeders; i++){
      availableFeederList[i-1] = stringReplace(availableFeederList[i], ",", " \t");
    }
    availableFeederList[numberOfFeeders-1] = "";
    numberOfFeeders--;
}

void setCoordinates(int x, int y)
{
  if(!initialized) {
    maxX = x;
    minX = x;
    maxY = y;
    minY = y;
    initialized = 1;
  }

  if(x < minX) {
    minX = x;
  }
  if(y < minY) {
    minY = y;
  }
  if(y > maxY) {
    maxY = y;  
  }
  if(x > maxX) {
    maxX = x;  
  }
}

void loadBoardInformation() {
  pnpCount            = 0;
  pnpStatsPartsTotal  = 0;
  pnpStatsPartsOk     = 0;
  pnpStatsPartsNew    = 0;
  pnpStatsPartsDnp    = 0;

  board(B) {
    pnpBasefile = B.name;

    B.elements(E) {

      int isSmd = 0;
      int isBottom = 0;

      E.package.contacts(C) {
        if (C.smd && C.smd.layer == 1) {
          isSmd = 1;
        }
        if (C.smd && C.smd.layer == 16) {
          isSmd = 1;
          isBottom = 1;
        }
      }

      if (isSmd) {
        pnpName[pnpCount]       = E.value + '-' + E.package.name;
        pnpDesignator[pnpCount] = E.name;
        pnpX[pnpCount]          = E.x;
        pnpY[pnpCount]          = E.y;
        pnpAngle[pnpCount]      = E.angle;
        pnpPos[pnpCount]        = isBottom;

        if(E.populate && E.attribute["POPULATE"] != "DNP"){
          pnpFeeder[pnpCount]   = getFeederId(pnpName[pnpCount]);
        } else {
          pnpFeeder[pnpCount]   = FEEDER_DNP;
        }

        pnpStatsPartsTotal++;
        if(pnpFeeder[pnpCount] == FEEDER_NEW){
          pnpStatsPartsNew++;
        } else if(pnpFeeder[pnpCount] == FEEDER_DNP){
          pnpStatsPartsDnp++;
        } else {
          pnpStatsPartsOk++;
        }

        pnpCount++;
      }


      B.wires(W) {
        if(W.layer == 20) {
          if(W.arc) {
            setCoordinates(W.arc.x1, W.arc.y1);
            setCoordinates(W.arc.x2, W.arc.y2);
            
            int angle = W.arc.angle2 - W.arc.angle1;
            
            int set_elements = round(angle/90);
            int start_element = round(W.arc.angle1/90);
            start_element = start_element % 4;
            
            for(int i = start_element; i < (start_element + set_elements); i++) {
              if(i == 0) {
                setCoordinates(W.arc.xc - W.arc.radius, W.arc.y1);
              } else if(i == 1) {
                setCoordinates(W.arc.x2, W.arc.yc + W.arc.radius);
              } else if(i == 2) {
                setCoordinates(W.arc.xc + W.arc.radius, W.arc.y1);
              } else if(i == 3) {
                setCoordinates(W.arc.x2, W.arc.yc - W.arc.radius);
              }
            }
          } else {
            setCoordinates(W.x1, W.y1);
            setCoordinates(W.x2, W.y2);
          }
        }
      }

      B.circles(C) {
        if(C.layer == 20) {
          setCoordinates(C.x + C.radius, C.y + C.radius);
          setCoordinates(C.x - C.radius, C.y - C.radius);
        }
      }


    } 
  }
}

int showListOfDevices()
{
  int selected = 0;
  int sorted = 0;
  int quantity = 1;
  int enableTop     = 1;
  int enableBottom  = 1;
  real frameX = 0;
  real frameY = 0;

  downloadFeederData();

  //bomLoadData();
  while(1)
  {
    loadBoardInformation();

    string partlist[];
    for(int i = 0; i < pnpCount; i++){
      partlist[i] = "";
      string feeder = "";
      if(pnpFeeder[i] == FEEDER_NEW){
        feeder = "No feeder assigned!";
      } else if(pnpFeeder[i] == FEEDER_DNP){
        feeder = "Do not mount!";
      } else {
        sprintf(feeder, "%d", pnpFeeder[i]);
      }

      sprintf(partlist[i], "%s\t%s\t%s\t%.2fmm\t%.2fmm\t%.1f°\t%s", pnpDesignator[i], pnpName[i], (pnpPos[i]==0)?"Top":"Bottom", u2mm(pnpX[i]), u2mm(pnpY[i]), pnpAngle[i], feeder);
    }
  
    int dstatus = dlgDialog("Feeder configuration"){
      dlgHBoxLayout{
        dlgVBoxLayout dlgSpacing(800);
        dlgTabWidget {
          dlgTabPage("Parts overview") {
            dlgListView("Designator\tComponent\tPosition\tPos X\tPos Y\tAngle\tFeeder", partlist, selected, sorted){
              dlgAccept();
            }
          }
          dlgTabPage("Feeder config") {
            dlgListView(availableFeederHeadline, availableFeederList, selected, sorted){
              dlgAccept();
            }
          }
        }
        dlgVBoxLayout {
          dlgGroup("Statistics") { 
            dlgHBoxLayout{ dlgLabel("Parts total:\t\t");       dlgLabel(itoa(pnpStatsPartsTotal)); }
            dlgHBoxLayout{ dlgLabel("Parts ok:\t\t");          dlgLabel(itoa(pnpStatsPartsOk));    }
            dlgHBoxLayout{ dlgLabel("Parts not assigned:\t");  dlgLabel(itoa(pnpStatsPartsNew));   }
            dlgHBoxLayout{ dlgLabel("Parts not mounted:\t");   dlgLabel(itoa(pnpStatsPartsDnp));   }
            dlgPushButton("Refresh feeder list") {
              downloadFeederData();
              dlgAccept();
            }
          }
          dlgGroup("Output") {
            dlgHBoxLayout{ dlgLabel("Offset X:\t");         dlgRealEdit(offsetX, 0, 200); } 
            dlgHBoxLayout{ dlgLabel("Offset Y:\t");         dlgRealEdit(offsetY, 0, 200); } 
            dlgCheckBox("Top placement data", enableTop);
            dlgCheckBox("Bottom placement data", enableBottom);
            dlgPushButton("Save output file") {
              if(enableTop){
                writeOutputFile(0, "-top");
              }
              if(enableBottom){
                writeOutputFile(1, "-bot");
              }
              dlgAccept();
            }           
          }
          dlgStretch(1);
        }
      }
    };

    if(dstatus == -1){break;}
  }

  return 1;
}

if (!board) {
    dlgMessageBox("\n    Start this ULP in a Board    \n");
    exit (0);  
} else {
    showListOfDevices();
}
